{"version":3,"names":[],"mappings":"","sources":["scripts/encryption/encryption-helper.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * PLEASE NOTE: This is in no way complete. This is just enabling\n * some testing in the browser / on github pages.\n *\n * Massive H/T to Peter Beverloo for this.\n */\n\n/* eslint-env browser */\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _hkdf = require('./hkdf.js');\n\nvar _hkdf2 = _interopRequireDefault(_hkdf);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Length, in bytes, of a P-256 field element. Expected format of the private key.\nvar PRIVATE_KEY_BYTES = 32;\n\n// Length, in bytes, of a P-256 public key in uncompressed EC form per SEC 2.3.3. This sequence must\n// start with 0x04. Expected format of the public key.\nvar PUBLIC_KEY_BYTES = 65;\n\n// Length, in bytes, of the salt that should be used for the message.\nvar SALT_BYTES = 16;\n\nvar joinUnit8Arrays = function joinUnit8Arrays(allUint8Arrays) {\n  // Super inefficient. But easier to follow than allocating the\n  // array with the correct size and position values in that array\n  // as required.\n  return allUint8Arrays.reduce(function (cumulativeValue, nextValue) {\n    var joinedArray = new Uint8Array(cumulativeValue.byteLength + nextValue.byteLength);\n    joinedArray.set(cumulativeValue, 0);\n    joinedArray.set(nextValue, cumulativeValue.byteLength);\n    return joinedArray;\n  }, new Uint8Array());\n};\n\nvar EncryptionHelper = function () {\n  function EncryptionHelper(serverKeys, salt) {\n    _classCallCheck(this, EncryptionHelper);\n\n    if (!serverKeys || !serverKeys.publicKey || !serverKeys.privateKey) {\n      throw new Error('Bad server keys. Use ' + 'EncryptionHelperFactory.generateKeys()');\n    }\n\n    if (!salt) {\n      throw new Error('Bad salt value. Use ' + 'EncryptionHelperFactory.generateSalt()');\n    }\n\n    this._serverKeys = serverKeys;\n    this._salt = salt;\n  }\n\n  _createClass(EncryptionHelper, [{\n    key: 'getPublicServerKey',\n    value: function getPublicServerKey() {\n      return this._serverKeys.publicKey;\n    }\n  }, {\n    key: 'getPrivateServerKey',\n    value: function getPrivateServerKey() {\n      return this._serverKeys.privateKey;\n    }\n  }, {\n    key: 'getSharedSecret',\n    value: function getSharedSecret(publicKeyString) {\n      var _this = this;\n\n      return Promise.resolve().then(function () {\n        return EncryptionHelper.stringKeysToCryptoKeys(publicKeyString);\n      }).then(function (keys) {\n        return keys.publicKey;\n      }).then(function (publicKey) {\n        if (!(publicKey instanceof CryptoKey)) {\n          throw new Error('The publicKey must be a CryptoKey.');\n        }\n\n        var algorithm = {\n          name: 'ECDH',\n          namedCurve: 'P-256',\n          public: publicKey\n        };\n\n        return crypto.subtle.deriveBits(algorithm, _this.getPrivateServerKey(), 256);\n      });\n    }\n  }, {\n    key: 'getSalt',\n    value: function getSalt() {\n      return this._salt;\n    }\n  }, {\n    key: 'generateContext',\n    value: function generateContext(publicKeyString) {\n      var _this2 = this;\n\n      return Promise.resolve().then(function () {\n        return EncryptionHelper.stringKeysToCryptoKeys(publicKeyString);\n      }).then(function (keys) {\n        return EncryptionHelper.exportCryptoKeys(keys.publicKey).then(function (keys) {\n          return keys.publicKey;\n        });\n      }).then(function (clientPublicKey) {\n        return EncryptionHelper.exportCryptoKeys(_this2.getPublicServerKey()).then(function (keys) {\n          return {\n            clientPublicKey: clientPublicKey,\n            serverPublicKey: keys.publicKey\n          };\n        });\n      }).then(function (keys) {\n        var utf8Encoder = new TextEncoder('utf-8');\n        var labelUnit8Array = utf8Encoder.encode('P-256');\n        var paddingUnit8Array = new Uint8Array(1).fill(0);\n\n        var clientPublicKeyLengthUnit8Array = new Uint8Array(2);\n        clientPublicKeyLengthUnit8Array[0] = 0x00;\n        clientPublicKeyLengthUnit8Array[1] = keys.clientPublicKey.byteLength;\n\n        var serverPublicKeyLengthBuffer = new Uint8Array(2);\n        serverPublicKeyLengthBuffer[0] = 0x00;\n        serverPublicKeyLengthBuffer[1] = keys.serverPublicKey.byteLength;\n\n        return joinUnit8Arrays([labelUnit8Array, paddingUnit8Array, clientPublicKeyLengthUnit8Array, keys.clientPublicKey, serverPublicKeyLengthBuffer, keys.serverPublicKey]);\n      });\n    }\n  }, {\n    key: 'generateCEKInfo',\n    value: function generateCEKInfo(publicKeyString) {\n      var _this3 = this;\n\n      return Promise.resolve().then(function () {\n        var utf8Encoder = new TextEncoder('utf-8');\n        var contentEncoding8Array = utf8Encoder.encode('Content-Encoding: aesgcm');\n        var paddingUnit8Array = new Uint8Array(1).fill(0);\n        return _this3.generateContext(publicKeyString).then(function (contextBuffer) {\n          return joinUnit8Arrays([contentEncoding8Array, paddingUnit8Array, contextBuffer]);\n        });\n      });\n    }\n  }, {\n    key: 'generateNonceInfo',\n    value: function generateNonceInfo(publicKeyString) {\n      var _this4 = this;\n\n      return Promise.resolve().then(function () {\n        var utf8Encoder = new TextEncoder('utf-8');\n        var contentEncoding8Array = utf8Encoder.encode('Content-Encoding: nonce');\n        var paddingUnit8Array = new Uint8Array(1).fill(0);\n        return _this4.generateContext(publicKeyString).then(function (contextBuffer) {\n          return joinUnit8Arrays([contentEncoding8Array, paddingUnit8Array, contextBuffer]);\n        });\n      });\n    }\n  }, {\n    key: 'generatePRK',\n    value: function generatePRK(subscription) {\n      return this.getSharedSecret(subscription.keys.p256dh).then(function (sharedSecret) {\n        var utf8Encoder = new TextEncoder('utf-8');\n        var authInfoUint8Array = utf8Encoder.encode('Content-Encoding: auth\\0');\n\n        var hkdf = new _hkdf2.default(sharedSecret, EncryptionHelper.base64UrlToUint8Array(subscription.keys.auth));\n        return hkdf.generate(authInfoUint8Array, 32);\n      });\n    }\n  }, {\n    key: 'generateEncryptionKeys',\n    value: function generateEncryptionKeys(subscription) {\n      var _this5 = this;\n\n      return Promise.all([this.generatePRK(subscription), this.generateCEKInfo(subscription.keys.p256dh), this.generateNonceInfo(subscription.keys.p256dh)]).then(function (results) {\n        var prk = results[0];\n        var cekInfo = results[1];\n        var nonceInfo = results[2];\n\n        var cekHKDF = new _hkdf2.default(prk, _this5._salt);\n        var nonceHKDF = new _hkdf2.default(prk, _this5._salt);\n        return Promise.all([cekHKDF.generate(cekInfo, 16), nonceHKDF.generate(nonceInfo, 12)]);\n      }).then(function (results) {\n        return {\n          contentEncryptionKey: results[0],\n          nonce: results[1]\n        };\n      });\n    }\n  }, {\n    key: 'encryptMessage',\n    value: function encryptMessage(subscription, payload) {\n      var _this6 = this;\n\n      return this.generateEncryptionKeys(subscription).then(function (encryptionKeys) {\n        return crypto.subtle.importKey('raw', encryptionKeys.contentEncryptionKey, 'AES-GCM', true, ['decrypt', 'encrypt']).then(function (contentEncryptionCryptoKey) {\n          encryptionKeys.contentEncryptionCryptoKey = contentEncryptionCryptoKey;\n          return encryptionKeys;\n        });\n      }).then(function (encryptionKeys) {\n        var paddingBytes = 0;\n        var paddingUnit8Array = new Uint8Array(2 + paddingBytes);\n        var utf8Encoder = new TextEncoder('utf-8');\n        var payloadUint8Array = utf8Encoder.encode(payload);\n        var recordUint8Array = new Uint8Array(paddingUnit8Array.byteLength + payloadUint8Array.byteLength);\n        recordUint8Array.set(paddingUnit8Array, 0);\n        recordUint8Array.set(payloadUint8Array, paddingUnit8Array.byteLength);\n\n        var algorithm = {\n          name: 'AES-GCM',\n          tagLength: 128,\n          iv: encryptionKeys.nonce\n        };\n\n        return crypto.subtle.encrypt(algorithm, encryptionKeys.contentEncryptionCryptoKey, recordUint8Array);\n      }).then(function (encryptedPayloadArrayBuffer) {\n        return EncryptionHelper.exportCryptoKeys(_this6.getPublicServerKey()).then(function (keys) {\n          return {\n            cipherText: encryptedPayloadArrayBuffer,\n            salt: EncryptionHelper.uint8ArrayToBase64Url(_this6.getSalt()),\n            publicServerKey: EncryptionHelper.uint8ArrayToBase64Url(keys.publicKey)\n          };\n        });\n      });\n    }\n  }], [{\n    key: 'exportCryptoKeys',\n    value: function exportCryptoKeys(publicKey, privateKey) {\n      return Promise.resolve().then(function () {\n        var promises = [];\n        promises.push(crypto.subtle.exportKey('jwk', publicKey).then(function (jwk) {\n          var x = EncryptionHelper.base64UrlToUint8Array(jwk.x);\n          var y = EncryptionHelper.base64UrlToUint8Array(jwk.y);\n\n          var publicKey = new Uint8Array(65);\n          publicKey.set([0x04], 0);\n          publicKey.set(x, 1);\n          publicKey.set(y, 33);\n\n          return publicKey;\n        }));\n\n        if (privateKey) {\n          promises.push(crypto.subtle.exportKey('jwk', privateKey).then(function (jwk) {\n            return EncryptionHelper.base64UrlToUint8Array(jwk.d);\n          }));\n        }\n\n        return Promise.all(promises);\n      }).then(function (exportedKeys) {\n        var result = {\n          publicKey: exportedKeys[0]\n        };\n\n        if (exportedKeys.length > 1) {\n          result.privateKey = exportedKeys[1];\n        }\n\n        return result;\n      });\n    }\n  }, {\n    key: 'stringKeysToCryptoKeys',\n    value: function stringKeysToCryptoKeys(publicKey, privateKey) {\n      if (!(typeof publicKey === 'string')) {\n        throw new Error('The publicKey is expected to be an String.');\n      }\n\n      var publicKeyUnitArray = EncryptionHelper.base64UrlToUint8Array(publicKey);\n      if (publicKeyUnitArray.byteLength !== PUBLIC_KEY_BYTES) {\n        throw new Error('The publicKey is expected to be ' + PUBLIC_KEY_BYTES + ' bytes.');\n      }\n\n      var publicBuffer = new Uint8Array(publicKeyUnitArray);\n      if (publicBuffer[0] !== 0x04) {\n        throw new Error('The publicKey is expected to start with an ' + '0x04 byte.');\n      }\n\n      var jwk = {\n        kty: 'EC',\n        crv: 'P-256',\n        x: EncryptionHelper.uint8ArrayToBase64Url(publicBuffer, 1, 33),\n        y: EncryptionHelper.uint8ArrayToBase64Url(publicBuffer, 33, 65),\n        ext: true\n      };\n\n      var keyPromises = [];\n      keyPromises.push(crypto.subtle.importKey('jwk', jwk, { name: 'ECDH', namedCurve: 'P-256' }, true, []));\n\n      if (privateKey) {\n        if (!(typeof privateKey === 'string')) {\n          throw new Error('The privateKey is expected to be an String.');\n        }\n\n        var privateKeyArray = EncryptionHelper.base64UrlToUint8Array(privateKey);\n\n        if (privateKeyArray.byteLength !== PRIVATE_KEY_BYTES) {\n          throw new Error('The privateKey is expected to be ' + PRIVATE_KEY_BYTES + ' bytes.');\n        }\n\n        // d must be defined after the importKey call for public\n        jwk.d = EncryptionHelper.uint8ArrayToBase64Url(new Uint8Array(privateKeyArray));\n        keyPromises.push(crypto.subtle.importKey('jwk', jwk, { name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']));\n      }\n\n      return Promise.all(keyPromises).then(function (keys) {\n        var keyPair = {\n          publicKey: keys[0]\n        };\n        if (keys.length > 1) {\n          keyPair.privateKey = keys[1];\n        }\n        return keyPair;\n      });\n    }\n  }, {\n    key: 'uint8ArrayToBase64Url',\n    value: function uint8ArrayToBase64Url(uint8Array, start, end) {\n      start = start || 0;\n      end = end || uint8Array.byteLength;\n\n      var base64 = btoa(String.fromCharCode.apply(null, uint8Array.slice(start, end)));\n      return base64.replace(/\\=/g, '') // eslint-disable-line no-useless-escape\n      .replace(/\\+/g, '-').replace(/\\//g, '_');\n    }\n\n    // Converts the URL-safe base64 encoded |base64UrlData| to an Uint8Array buffer.\n\n  }, {\n    key: 'base64UrlToUint8Array',\n    value: function base64UrlToUint8Array(base64UrlData) {\n      var padding = '='.repeat((4 - base64UrlData.length % 4) % 4);\n      var base64 = (base64UrlData + padding).replace(/\\-/g, '+').replace(/_/g, '/');\n\n      var rawData = atob(base64);\n      var buffer = new Uint8Array(rawData.length);\n\n      for (var i = 0; i < rawData.length; ++i) {\n        buffer[i] = rawData.charCodeAt(i);\n      }\n      return buffer;\n    }\n  }]);\n\n  return EncryptionHelper;\n}();\n\nexports.default = EncryptionHelper;\n\nvar EncryptionHelperFactory = function () {\n  function EncryptionHelperFactory() {\n    _classCallCheck(this, EncryptionHelperFactory);\n  }\n\n  _createClass(EncryptionHelperFactory, null, [{\n    key: 'generateHelper',\n    value: function generateHelper(options) {\n      return Promise.resolve().then(function () {\n        if (options && options.serverKeys) {\n          return EncryptionHelperFactory.importKeys(options);\n        }\n\n        return EncryptionHelperFactory.generateKeys(options);\n      }).then(function (keys) {\n        var salt = null;\n        if (options && options.salt) {\n          salt = EncryptionHelper.base64UrlToUint8Array(options.salt);\n        } else {\n          salt = crypto.getRandomValues(new Uint8Array(16));\n        }\n        return new EncryptionHelper(keys, salt);\n      });\n    }\n  }, {\n    key: 'importKeys',\n    value: function importKeys(options) {\n      if (!options || !options.serverKeys || !options.serverKeys.publicKey || !options.serverKeys.privateKey) {\n        return Promise.reject(new Error('Bad options for key import'));\n      }\n\n      return Promise.resolve().then(function () {\n        return EncryptionHelper.stringKeysToCryptoKeys(options.serverKeys.publicKey, options.serverKeys.privateKey);\n      });\n    }\n  }, {\n    key: 'generateKeys',\n    value: function generateKeys() {\n      // True is to make the keys extractable\n      return crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']);\n    }\n  }, {\n    key: 'generateSalt',\n    value: function generateSalt() {\n      return crypto.getRandomValues(new Uint8Array(SALT_BYTES));\n    }\n  }]);\n\n  return EncryptionHelperFactory;\n}();\n\nexports.default = EncryptionHelperFactory;\n\n\nif (typeof window !== 'undefined') {\n  window.gauntface = window.gauntface || {};\n  window.gauntface.EncryptionHelperFactory = EncryptionHelperFactory;\n  window.gauntface.EncryptionHelper = EncryptionHelper;\n}\n\n},{\"./hkdf.js\":2}],2:[function(require,module,exports){\n/* eslint-env browser */\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _hmac = require('./hmac.js');\n\nvar _hmac2 = _interopRequireDefault(_hmac);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar HKDF = function () {\n  function HKDF(ikm, salt) {\n    _classCallCheck(this, HKDF);\n\n    this._ikm = ikm;\n    this._salt = salt;\n\n    this._hmac = new _hmac2.default(salt);\n  }\n\n  _createClass(HKDF, [{\n    key: 'generate',\n    value: function generate(info, byteLength) {\n      var fullInfoBuffer = new Uint8Array(info.byteLength + 1);\n      fullInfoBuffer.set(info, 0);\n      fullInfoBuffer.set(new Uint8Array(1).fill(1), info.byteLength);\n\n      return this._hmac.sign(this._ikm).then(function (prk) {\n        var nextHmac = new _hmac2.default(prk);\n        return nextHmac.sign(fullInfoBuffer);\n      }).then(function (nextPrk) {\n        return nextPrk.slice(0, byteLength);\n      });\n    }\n  }]);\n\n  return HKDF;\n}();\n\nexports.default = HKDF;\n\n\nif (typeof window !== 'undefined') {\n  window.gauntface = window.gauntface || {};\n  window.gauntface.HKDF = HKDF;\n}\n\n},{\"./hmac.js\":3}],3:[function(require,module,exports){\n/* eslint-env browser */\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar HMAC = function () {\n  function HMAC(ikm) {\n    _classCallCheck(this, HMAC);\n\n    this._ikm = ikm;\n  }\n\n  _createClass(HMAC, [{\n    key: 'sign',\n    value: function sign(input) {\n      return crypto.subtle.importKey('raw', this._ikm, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']).then(function (key) {\n        return crypto.subtle.sign('HMAC', key, input);\n      });\n    }\n  }]);\n\n  return HMAC;\n}();\n\nexports.default = HMAC;\n\n\nif (typeof window !== 'undefined') {\n  window.gauntface = window.gauntface || {};\n  window.gauntface.HMAC = HMAC;\n}\n\n},{}]},{},[1]);\n"],"file":"scripts/encryption/encryption-helper.js","sourceRoot":"/source/"}