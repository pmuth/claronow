{"version":3,"names":[],"mappings":"","sources":["scripts/app-controller.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-env browser */\n\nvar _pushClient = require('./push-client.js');\n\nvar _pushClient2 = _interopRequireDefault(_pushClient);\n\nvar _encryptionHelper = require('./encryption/encryption-helper');\n\nvar _encryptionHelper2 = _interopRequireDefault(_encryptionHelper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AppController = function () {\n  function AppController() {\n    var _this = this;\n\n    _classCallCheck(this, AppController);\n\n    // Define a different server URL here if desire.\n    this._PUSH_SERVER_URL = '';\n    this._API_KEY = 'AIzaSyBBh4ddPa96rQQNxqiq_qQj7sq1JdsNQUQ';\n\n    // This div contains the UI for CURL commands to trigger a push\n    this._sendPushOptions = document.querySelector('.js-send-push-options');\n    this._payloadTextField = document.querySelector('.js-payload-textfield');\n    this._stateMsg = document.querySelector('.js-state-msg');\n    this._payloadTextField.oninput = function () {\n      Promise.all([_this.updateCurlCommand(), _this.updateXHRButton()]).then(function () {\n        _this.updateOrMessage();\n      });\n    };\n\n    // Below this comment is code to initialise a material design lite view.\n    var toggleSwitch = document.querySelector('.js-push-toggle-switch');\n    if (toggleSwitch.classList.contains('is-upgraded')) {\n      this.ready = Promise.resolve();\n      this._uiInitialised(toggleSwitch.MaterialSwitch);\n    } else {\n      this.ready = new Promise(function (resolve) {\n        var mdlUpgradeCb = function mdlUpgradeCb() {\n          if (!toggleSwitch.classList.contains('is-upgraded')) {\n            return;\n          }\n\n          _this._uiInitialised(toggleSwitch.MaterialSwitch);\n          document.removeEventListener(mdlUpgradeCb);\n\n          resolve();\n        };\n\n        // This is to wait for MDL initialising\n        document.addEventListener('mdl-componentupgraded', mdlUpgradeCb);\n      });\n    }\n  }\n\n  _createClass(AppController, [{\n    key: '_uiInitialised',\n    value: function _uiInitialised(toggleSwitch) {\n      var _this2 = this;\n\n      this._stateChangeListener = this._stateChangeListener.bind(this);\n      this._subscriptionUpdate = this._subscriptionUpdate.bind(this);\n\n      this._toggleSwitch = toggleSwitch;\n      this._pushClient = new _pushClient2.default(this._stateChangeListener, this._subscriptionUpdate);\n\n      document.querySelector('.js-push-toggle-switch > input').addEventListener('click', function (event) {\n        // Inverted because clicking will change the checked state by\n        // the time we get here\n        if (event.target.checked) {\n          _this2._pushClient.subscribeDevice();\n        } else {\n          _this2._pushClient.unsubscribeDevice();\n        }\n      });\n\n      var sendPushViaXHRButton = document.querySelector('.js-send-push-button');\n      sendPushViaXHRButton.addEventListener('click', function () {\n        if (_this2._currentSubscription) {\n          _this2.sendPushMessage(_this2._currentSubscription, _this2._payloadTextField.value);\n        }\n      });\n    }\n  }, {\n    key: 'registerServiceWorker',\n    value: function registerServiceWorker() {\n      var _this3 = this;\n\n      // Check that service workers are supported\n      if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.register('./service-worker.js').catch(function (err) {\n          _this3.showErrorMessage('Unable to Register SW', 'Sorry this demo requires a service worker to work and it ' + 'was didn\\'t seem to install - sorry :(');\n          console.error(err);\n        });\n      } else {\n        this.showErrorMessage('Service Worker Not Supported', 'Sorry this demo requires service worker support in your browser. ' + 'Please try this demo in Chrome or Firefox Nightly.');\n      }\n    }\n  }, {\n    key: '_stateChangeListener',\n    value: function _stateChangeListener(state, data) {\n      // console.log(state);\n      if (typeof state.interactive !== 'undefined') {\n        if (state.interactive) {\n          this._toggleSwitch.enable();\n        } else {\n          this._toggleSwitch.disable();\n        }\n      }\n\n      if (typeof state.pushEnabled !== 'undefined') {\n        if (state.pushEnabled) {\n          this._toggleSwitch.on();\n        } else {\n          this._toggleSwitch.off();\n        }\n      }\n\n      switch (state.id) {\n        case 'ERROR':\n          this.showErrorMessage('Ooops a Problem Occurred', data);\n          break;\n        default:\n          break;\n      }\n    }\n  }, {\n    key: '_subscriptionUpdate',\n    value: function _subscriptionUpdate(subscription) {\n      var _this4 = this;\n\n      this._currentSubscription = subscription;\n\n      if (!subscription) {\n        // Remove any subscription from your servers if you have\n        // set it up.\n        this._sendPushOptions.style.opacity = 0;\n        return;\n      }\n\n      // This is too handle old versions of Firefox where keys would exist\n      // but auth wouldn't\n      var payloadTextfieldContainer = document.querySelector('.js-payload-textfield-container');\n      var subscriptionObject = JSON.parse(JSON.stringify(subscription));\n      if (subscriptionObject && subscriptionObject.keys && subscriptionObject.keys.auth && subscriptionObject.keys.p256dh) {\n        payloadTextfieldContainer.classList.remove('hidden');\n      } else {\n        payloadTextfieldContainer.classList.add('hidden');\n      }\n\n      Promise.all([this.updateCurlCommand(), this.updateXHRButton()]).then(function () {\n        _this4.updateOrMessage();\n      });\n\n      // Display the UI\n      this._sendPushOptions.style.opacity = 1;\n    }\n  }, {\n    key: 'updateCurlCommand',\n    value: function updateCurlCommand() {\n      var _this5 = this;\n\n      var payloadText = this._payloadTextField.value;\n      var payloadPromise = Promise.resolve(null);\n      if (payloadText && payloadText.trim().length > 0) {\n        payloadPromise = _encryptionHelper2.default.generateHelper().then(function (encryptionHelper) {\n          return encryptionHelper.encryptMessage(JSON.parse(JSON.stringify(_this5._currentSubscription)), payloadText);\n        });\n      }\n\n      return payloadPromise.then(function (encryptedPayload) {\n        var curlContainer = document.querySelector('.js-curl-container');\n        var curlCommand = void 0;\n\n        // GCM Command\n        if (_this5._currentSubscription.endpoint.indexOf('https://android.googleapis.com/gcm/send') === 0) {\n          curlCommand = _this5.produceGCMProprietaryCURLCommand(_this5._currentSubscription, encryptedPayload);\n\n          // Web Push Protocol\n        } else if (payloadText && payloadText.trim().length > 0) {\n            // Turn off curl command\n            curlContainer.style.display = 'none';\n            _this5._stateMsg.textContent = 'Note: Push messages with a payload ' + 'can\\'t be sent with a cURL command due to the body of the web ' + 'push protocol request being a stream.';\n            return;\n          } else {\n            _this5._stateMsg.textContent = '';\n            curlCommand = _this5.produceWebPushProtocolCURLCommand(_this5._currentSubscription, encryptedPayload);\n          }\n\n        curlContainer.style.display = 'block';\n        var curlCodeElement = document.querySelector('.js-curl-code');\n        curlCodeElement.innerHTML = curlCommand;\n      });\n    }\n  }, {\n    key: 'updateXHRButton',\n    value: function updateXHRButton() {\n      var buttonContainer = document.querySelector('.js-xhr-button-container');\n      if (this._currentSubscription.endpoint.indexOf('https://android.googleapis.com/gcm/send') === 0 && this._payloadTextField.value.trim().length > 0) {\n        buttonContainer.style.display = 'none';\n        return;\n      }\n\n      buttonContainer.style.display = 'block';\n    }\n  }, {\n    key: 'updateOrMessage',\n    value: function updateOrMessage() {\n      var orMessage = document.querySelector('.js-push-options-or');\n      var buttonContainer = document.querySelector('.js-xhr-button-container');\n      var curlContainer = document.querySelector('.js-curl-container');\n\n      var orDisplay = buttonContainer.style.display === 'none' || curlContainer.style.display === 'none' ? 'none' : 'block';\n\n      orMessage.style.display = orDisplay;\n    }\n  }, {\n    key: 'sendPushMessage',\n    value: function sendPushMessage(subscription, payloadText) {\n      var _this6 = this;\n\n      var payloadPromise = Promise.resolve(null);\n      if (payloadText && payloadText.trim().length > 0) {\n        payloadPromise = _encryptionHelper2.default.generateHelper().then(function (encryptionHelper) {\n          console.log(JSON.stringify(subscription));\n          return encryptionHelper.encryptMessage(JSON.parse(JSON.stringify(subscription)), payloadText);\n        });\n      }\n\n      payloadPromise.then(function (encryptedPayload) {\n        if (subscription.endpoint.indexOf('https://android.googleapis.com/gcm/send') === 0) {\n          _this6.useGCMProtocol(subscription, encryptedPayload);\n        } else {\n          _this6.useWebPushProtocol(subscription, encryptedPayload);\n        }\n      });\n    }\n  }, {\n    key: 'toBase64',\n    value: function toBase64(arrayBuffer, start, end) {\n      start = start || 0;\n      end = end || arrayBuffer.byteLength;\n\n      var partialBuffer = new Uint8Array(arrayBuffer.slice(start, end));\n      return btoa(String.fromCharCode.apply(null, partialBuffer));\n    }\n  }, {\n    key: 'useGCMProtocol',\n    value: function useGCMProtocol(subscription, encryptedPayload) {\n      var _this7 = this;\n\n      console.log('Sending XHR to GCM Protocol endpoint');\n\n      var headers = new Headers();\n      headers.append('Content-Type', 'application/json');\n      headers.append('Authorization', 'key=' + this._API_KEY);\n\n      var endpointSections = subscription.endpoint.split('/');\n      var subscriptionId = endpointSections[endpointSections.length - 1];\n      var msgBody = {\n        registration_ids: [subscriptionId] // eslint-disable-line camelcase\n      };\n\n      if (encryptedPayload) {\n        msgBody.raw_data = this.toBase64(encryptedPayload.cipherText); // eslint-disable-line camelcase\n\n        headers.append('Encryption', 'salt=' + encryptedPayload.salt);\n        headers.append('Crypto-Key', 'dh=' + encryptedPayload.publicServerKey);\n        headers.append('Content-Encoding', 'aesgcm');\n      }\n\n      fetch('https://android.googleapis.com/gcm/send', {\n        method: 'post',\n        headers: headers,\n        body: JSON.stringify(msgBody)\n      }).then(function (response) {\n        if (response.type === 'opaque') {\n          return;\n        }\n\n        return response.json().then(function (responseObj) {\n          if (responseObj.failure !== 0) {\n            console.log('Failed GCM response: ', responseObj);\n            throw new Error('Failed to send push message via GCM');\n          }\n        });\n      }).catch(function (err) {\n        _this7.showErrorMessage('Ooops Unable to Send a Push', err);\n      });\n    }\n  }, {\n    key: 'useWebPushProtocol',\n    value: function useWebPushProtocol(subscription, encryptedPayload) {\n      var _this8 = this;\n\n      console.log('Sending XHR to Web Push Protocol endpoint');\n      var headers = new Headers();\n      headers.append('TTL', 60);\n\n      var fetchOptions = {\n        method: 'post',\n        headers: headers\n      };\n\n      if (encryptedPayload) {\n        fetchOptions.body = encryptedPayload.cipherText;\n\n        headers.append('Encryption', 'salt=' + encryptedPayload.salt);\n        headers.append('Crypto-Key', 'dh=' + encryptedPayload.publicServerKey);\n        headers.append('Content-Encoding', 'application/octet-stream');\n        headers.append('Content-Encoding', 'aesgcm');\n      }\n\n      fetch(subscription.endpoint, fetchOptions).then(function (response) {\n        if (response.status >= 400 && response.status < 500) {\n          console.log('Failed web push response: ', response, response.status);\n          throw new Error('Failed to send push message via web push protocol');\n        }\n      }).catch(function (err) {\n        _this8.showErrorMessage('Ooops Unable to Send a Push', err);\n      });\n    }\n  }, {\n    key: 'produceGCMProprietaryCURLCommand',\n    value: function produceGCMProprietaryCURLCommand(subscription, encryptedPayload) {\n      var additionalHeaders = '';\n      var additionalBody = '';\n      if (encryptedPayload) {\n        additionalBody = ', \\\\\"raw_data\\\\\": \\\\\"' + this.toBase64(encryptedPayload.cipherText) + '\\\\\"';\n\n        additionalHeaders += ' --header \"Encryption: salt=' + encryptedPayload.salt + '\"';\n        additionalHeaders += ' --header \"Crypto-Key: dh=' + encryptedPayload.publicServerKey + '\"';\n        additionalHeaders += ' --header \"Content-Encoding: aesgcm\"';\n\n        this._stateMsg.textContent = 'Note: Push messages with a payload ' + 'can\\'t be sent to GCM due to a CORs issue. Trigger a push ' + 'message with the cURL command below.';\n      } else {\n        this._stateMsg.textContent = '';\n      }\n\n      var curlEndpoint = 'https://android.googleapis.com/gcm/send';\n      var endpointSections = subscription.endpoint.split('/');\n      var subscriptionId = endpointSections[endpointSections.length - 1];\n      var curlCommand = 'curl --header \"Authorization: key=' + this._API_KEY + '\" --header \"Content-Type: application/json\"' + additionalHeaders + ' ' + curlEndpoint + ' -d \"{\\\\\"to\\\\\":\\\\\"' + subscriptionId + '\\\\\"' + additionalBody + '}\"';\n      return curlCommand;\n    }\n  }, {\n    key: 'produceWebPushProtocolCURLCommand',\n    value: function produceWebPushProtocolCURLCommand(subscription) {\n      // Payload body is a byte array so can't add to cURL command\n      var curlEndpoint = subscription.endpoint;\n      var curlCommand = 'curl --header \"TTL: 60\" --request POST ' + curlEndpoint;\n      return curlCommand;\n    }\n  }, {\n    key: 'showErrorMessage',\n    value: function showErrorMessage(title, message) {\n      var errorContainer = document.querySelector('.js-error-message-container');\n\n      var titleElement = errorContainer.querySelector('.js-error-title');\n      var messageElement = errorContainer.querySelector('.js-error-message');\n      titleElement.textContent = title;\n      messageElement.innerHTML = message;\n      errorContainer.style.opacity = 1;\n\n      var pushOptionsContainer = document.querySelector('.js-send-push-options');\n      pushOptionsContainer.style.display = 'none';\n    }\n  }]);\n\n  return AppController;\n}();\n\nexports.default = AppController;\n\n},{\"./encryption/encryption-helper\":2,\"./push-client.js\":5}],2:[function(require,module,exports){\n/**\n * PLEASE NOTE: This is in no way complete. This is just enabling\n * some testing in the browser / on github pages.\n *\n * Massive H/T to Peter Beverloo for this.\n */\n\n/* eslint-env browser */\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _hkdf = require('./hkdf.js');\n\nvar _hkdf2 = _interopRequireDefault(_hkdf);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Length, in bytes, of a P-256 field element. Expected format of the private key.\nvar PRIVATE_KEY_BYTES = 32;\n\n// Length, in bytes, of a P-256 public key in uncompressed EC form per SEC 2.3.3. This sequence must\n// start with 0x04. Expected format of the public key.\nvar PUBLIC_KEY_BYTES = 65;\n\n// Length, in bytes, of the salt that should be used for the message.\nvar SALT_BYTES = 16;\n\nvar joinUnit8Arrays = function joinUnit8Arrays(allUint8Arrays) {\n  // Super inefficient. But easier to follow than allocating the\n  // array with the correct size and position values in that array\n  // as required.\n  return allUint8Arrays.reduce(function (cumulativeValue, nextValue) {\n    var joinedArray = new Uint8Array(cumulativeValue.byteLength + nextValue.byteLength);\n    joinedArray.set(cumulativeValue, 0);\n    joinedArray.set(nextValue, cumulativeValue.byteLength);\n    return joinedArray;\n  }, new Uint8Array());\n};\n\nvar EncryptionHelper = function () {\n  function EncryptionHelper(serverKeys, salt) {\n    _classCallCheck(this, EncryptionHelper);\n\n    if (!serverKeys || !serverKeys.publicKey || !serverKeys.privateKey) {\n      throw new Error('Bad server keys. Use ' + 'EncryptionHelperFactory.generateKeys()');\n    }\n\n    if (!salt) {\n      throw new Error('Bad salt value. Use ' + 'EncryptionHelperFactory.generateSalt()');\n    }\n\n    this._serverKeys = serverKeys;\n    this._salt = salt;\n  }\n\n  _createClass(EncryptionHelper, [{\n    key: 'getPublicServerKey',\n    value: function getPublicServerKey() {\n      return this._serverKeys.publicKey;\n    }\n  }, {\n    key: 'getPrivateServerKey',\n    value: function getPrivateServerKey() {\n      return this._serverKeys.privateKey;\n    }\n  }, {\n    key: 'getSharedSecret',\n    value: function getSharedSecret(publicKeyString) {\n      var _this = this;\n\n      return Promise.resolve().then(function () {\n        return EncryptionHelper.stringKeysToCryptoKeys(publicKeyString);\n      }).then(function (keys) {\n        return keys.publicKey;\n      }).then(function (publicKey) {\n        if (!(publicKey instanceof CryptoKey)) {\n          throw new Error('The publicKey must be a CryptoKey.');\n        }\n\n        var algorithm = {\n          name: 'ECDH',\n          namedCurve: 'P-256',\n          public: publicKey\n        };\n\n        return crypto.subtle.deriveBits(algorithm, _this.getPrivateServerKey(), 256);\n      });\n    }\n  }, {\n    key: 'getSalt',\n    value: function getSalt() {\n      return this._salt;\n    }\n  }, {\n    key: 'generateContext',\n    value: function generateContext(publicKeyString) {\n      var _this2 = this;\n\n      return Promise.resolve().then(function () {\n        return EncryptionHelper.stringKeysToCryptoKeys(publicKeyString);\n      }).then(function (keys) {\n        return EncryptionHelper.exportCryptoKeys(keys.publicKey).then(function (keys) {\n          return keys.publicKey;\n        });\n      }).then(function (clientPublicKey) {\n        return EncryptionHelper.exportCryptoKeys(_this2.getPublicServerKey()).then(function (keys) {\n          return {\n            clientPublicKey: clientPublicKey,\n            serverPublicKey: keys.publicKey\n          };\n        });\n      }).then(function (keys) {\n        var utf8Encoder = new TextEncoder('utf-8');\n        var labelUnit8Array = utf8Encoder.encode('P-256');\n        var paddingUnit8Array = new Uint8Array(1).fill(0);\n\n        var clientPublicKeyLengthUnit8Array = new Uint8Array(2);\n        clientPublicKeyLengthUnit8Array[0] = 0x00;\n        clientPublicKeyLengthUnit8Array[1] = keys.clientPublicKey.byteLength;\n\n        var serverPublicKeyLengthBuffer = new Uint8Array(2);\n        serverPublicKeyLengthBuffer[0] = 0x00;\n        serverPublicKeyLengthBuffer[1] = keys.serverPublicKey.byteLength;\n\n        return joinUnit8Arrays([labelUnit8Array, paddingUnit8Array, clientPublicKeyLengthUnit8Array, keys.clientPublicKey, serverPublicKeyLengthBuffer, keys.serverPublicKey]);\n      });\n    }\n  }, {\n    key: 'generateCEKInfo',\n    value: function generateCEKInfo(publicKeyString) {\n      var _this3 = this;\n\n      return Promise.resolve().then(function () {\n        var utf8Encoder = new TextEncoder('utf-8');\n        var contentEncoding8Array = utf8Encoder.encode('Content-Encoding: aesgcm');\n        var paddingUnit8Array = new Uint8Array(1).fill(0);\n        return _this3.generateContext(publicKeyString).then(function (contextBuffer) {\n          return joinUnit8Arrays([contentEncoding8Array, paddingUnit8Array, contextBuffer]);\n        });\n      });\n    }\n  }, {\n    key: 'generateNonceInfo',\n    value: function generateNonceInfo(publicKeyString) {\n      var _this4 = this;\n\n      return Promise.resolve().then(function () {\n        var utf8Encoder = new TextEncoder('utf-8');\n        var contentEncoding8Array = utf8Encoder.encode('Content-Encoding: nonce');\n        var paddingUnit8Array = new Uint8Array(1).fill(0);\n        return _this4.generateContext(publicKeyString).then(function (contextBuffer) {\n          return joinUnit8Arrays([contentEncoding8Array, paddingUnit8Array, contextBuffer]);\n        });\n      });\n    }\n  }, {\n    key: 'generatePRK',\n    value: function generatePRK(subscription) {\n      return this.getSharedSecret(subscription.keys.p256dh).then(function (sharedSecret) {\n        var utf8Encoder = new TextEncoder('utf-8');\n        var authInfoUint8Array = utf8Encoder.encode('Content-Encoding: auth\\0');\n\n        var hkdf = new _hkdf2.default(sharedSecret, EncryptionHelper.base64UrlToUint8Array(subscription.keys.auth));\n        return hkdf.generate(authInfoUint8Array, 32);\n      });\n    }\n  }, {\n    key: 'generateEncryptionKeys',\n    value: function generateEncryptionKeys(subscription) {\n      var _this5 = this;\n\n      return Promise.all([this.generatePRK(subscription), this.generateCEKInfo(subscription.keys.p256dh), this.generateNonceInfo(subscription.keys.p256dh)]).then(function (results) {\n        var prk = results[0];\n        var cekInfo = results[1];\n        var nonceInfo = results[2];\n\n        var cekHKDF = new _hkdf2.default(prk, _this5._salt);\n        var nonceHKDF = new _hkdf2.default(prk, _this5._salt);\n        return Promise.all([cekHKDF.generate(cekInfo, 16), nonceHKDF.generate(nonceInfo, 12)]);\n      }).then(function (results) {\n        return {\n          contentEncryptionKey: results[0],\n          nonce: results[1]\n        };\n      });\n    }\n  }, {\n    key: 'encryptMessage',\n    value: function encryptMessage(subscription, payload) {\n      var _this6 = this;\n\n      return this.generateEncryptionKeys(subscription).then(function (encryptionKeys) {\n        return crypto.subtle.importKey('raw', encryptionKeys.contentEncryptionKey, 'AES-GCM', true, ['decrypt', 'encrypt']).then(function (contentEncryptionCryptoKey) {\n          encryptionKeys.contentEncryptionCryptoKey = contentEncryptionCryptoKey;\n          return encryptionKeys;\n        });\n      }).then(function (encryptionKeys) {\n        var paddingBytes = 0;\n        var paddingUnit8Array = new Uint8Array(2 + paddingBytes);\n        var utf8Encoder = new TextEncoder('utf-8');\n        var payloadUint8Array = utf8Encoder.encode(payload);\n        var recordUint8Array = new Uint8Array(paddingUnit8Array.byteLength + payloadUint8Array.byteLength);\n        recordUint8Array.set(paddingUnit8Array, 0);\n        recordUint8Array.set(payloadUint8Array, paddingUnit8Array.byteLength);\n\n        var algorithm = {\n          name: 'AES-GCM',\n          tagLength: 128,\n          iv: encryptionKeys.nonce\n        };\n\n        return crypto.subtle.encrypt(algorithm, encryptionKeys.contentEncryptionCryptoKey, recordUint8Array);\n      }).then(function (encryptedPayloadArrayBuffer) {\n        return EncryptionHelper.exportCryptoKeys(_this6.getPublicServerKey()).then(function (keys) {\n          return {\n            cipherText: encryptedPayloadArrayBuffer,\n            salt: EncryptionHelper.uint8ArrayToBase64Url(_this6.getSalt()),\n            publicServerKey: EncryptionHelper.uint8ArrayToBase64Url(keys.publicKey)\n          };\n        });\n      });\n    }\n  }], [{\n    key: 'exportCryptoKeys',\n    value: function exportCryptoKeys(publicKey, privateKey) {\n      return Promise.resolve().then(function () {\n        var promises = [];\n        promises.push(crypto.subtle.exportKey('jwk', publicKey).then(function (jwk) {\n          var x = EncryptionHelper.base64UrlToUint8Array(jwk.x);\n          var y = EncryptionHelper.base64UrlToUint8Array(jwk.y);\n\n          var publicKey = new Uint8Array(65);\n          publicKey.set([0x04], 0);\n          publicKey.set(x, 1);\n          publicKey.set(y, 33);\n\n          return publicKey;\n        }));\n\n        if (privateKey) {\n          promises.push(crypto.subtle.exportKey('jwk', privateKey).then(function (jwk) {\n            return EncryptionHelper.base64UrlToUint8Array(jwk.d);\n          }));\n        }\n\n        return Promise.all(promises);\n      }).then(function (exportedKeys) {\n        var result = {\n          publicKey: exportedKeys[0]\n        };\n\n        if (exportedKeys.length > 1) {\n          result.privateKey = exportedKeys[1];\n        }\n\n        return result;\n      });\n    }\n  }, {\n    key: 'stringKeysToCryptoKeys',\n    value: function stringKeysToCryptoKeys(publicKey, privateKey) {\n      if (!(typeof publicKey === 'string')) {\n        throw new Error('The publicKey is expected to be an String.');\n      }\n\n      var publicKeyUnitArray = EncryptionHelper.base64UrlToUint8Array(publicKey);\n      if (publicKeyUnitArray.byteLength !== PUBLIC_KEY_BYTES) {\n        throw new Error('The publicKey is expected to be ' + PUBLIC_KEY_BYTES + ' bytes.');\n      }\n\n      var publicBuffer = new Uint8Array(publicKeyUnitArray);\n      if (publicBuffer[0] !== 0x04) {\n        throw new Error('The publicKey is expected to start with an ' + '0x04 byte.');\n      }\n\n      var jwk = {\n        kty: 'EC',\n        crv: 'P-256',\n        x: EncryptionHelper.uint8ArrayToBase64Url(publicBuffer, 1, 33),\n        y: EncryptionHelper.uint8ArrayToBase64Url(publicBuffer, 33, 65),\n        ext: true\n      };\n\n      var keyPromises = [];\n      keyPromises.push(crypto.subtle.importKey('jwk', jwk, { name: 'ECDH', namedCurve: 'P-256' }, true, []));\n\n      if (privateKey) {\n        if (!(typeof privateKey === 'string')) {\n          throw new Error('The privateKey is expected to be an String.');\n        }\n\n        var privateKeyArray = EncryptionHelper.base64UrlToUint8Array(privateKey);\n\n        if (privateKeyArray.byteLength !== PRIVATE_KEY_BYTES) {\n          throw new Error('The privateKey is expected to be ' + PRIVATE_KEY_BYTES + ' bytes.');\n        }\n\n        // d must be defined after the importKey call for public\n        jwk.d = EncryptionHelper.uint8ArrayToBase64Url(new Uint8Array(privateKeyArray));\n        keyPromises.push(crypto.subtle.importKey('jwk', jwk, { name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']));\n      }\n\n      return Promise.all(keyPromises).then(function (keys) {\n        var keyPair = {\n          publicKey: keys[0]\n        };\n        if (keys.length > 1) {\n          keyPair.privateKey = keys[1];\n        }\n        return keyPair;\n      });\n    }\n  }, {\n    key: 'uint8ArrayToBase64Url',\n    value: function uint8ArrayToBase64Url(uint8Array, start, end) {\n      start = start || 0;\n      end = end || uint8Array.byteLength;\n\n      var base64 = btoa(String.fromCharCode.apply(null, uint8Array.slice(start, end)));\n      return base64.replace(/\\=/g, '') // eslint-disable-line no-useless-escape\n      .replace(/\\+/g, '-').replace(/\\//g, '_');\n    }\n\n    // Converts the URL-safe base64 encoded |base64UrlData| to an Uint8Array buffer.\n\n  }, {\n    key: 'base64UrlToUint8Array',\n    value: function base64UrlToUint8Array(base64UrlData) {\n      var padding = '='.repeat((4 - base64UrlData.length % 4) % 4);\n      var base64 = (base64UrlData + padding).replace(/\\-/g, '+').replace(/_/g, '/');\n\n      var rawData = atob(base64);\n      var buffer = new Uint8Array(rawData.length);\n\n      for (var i = 0; i < rawData.length; ++i) {\n        buffer[i] = rawData.charCodeAt(i);\n      }\n      return buffer;\n    }\n  }]);\n\n  return EncryptionHelper;\n}();\n\nexports.default = EncryptionHelper;\n\nvar EncryptionHelperFactory = function () {\n  function EncryptionHelperFactory() {\n    _classCallCheck(this, EncryptionHelperFactory);\n  }\n\n  _createClass(EncryptionHelperFactory, null, [{\n    key: 'generateHelper',\n    value: function generateHelper(options) {\n      return Promise.resolve().then(function () {\n        if (options && options.serverKeys) {\n          return EncryptionHelperFactory.importKeys(options);\n        }\n\n        return EncryptionHelperFactory.generateKeys(options);\n      }).then(function (keys) {\n        var salt = null;\n        if (options && options.salt) {\n          salt = EncryptionHelper.base64UrlToUint8Array(options.salt);\n        } else {\n          salt = crypto.getRandomValues(new Uint8Array(16));\n        }\n        return new EncryptionHelper(keys, salt);\n      });\n    }\n  }, {\n    key: 'importKeys',\n    value: function importKeys(options) {\n      if (!options || !options.serverKeys || !options.serverKeys.publicKey || !options.serverKeys.privateKey) {\n        return Promise.reject(new Error('Bad options for key import'));\n      }\n\n      return Promise.resolve().then(function () {\n        return EncryptionHelper.stringKeysToCryptoKeys(options.serverKeys.publicKey, options.serverKeys.privateKey);\n      });\n    }\n  }, {\n    key: 'generateKeys',\n    value: function generateKeys() {\n      // True is to make the keys extractable\n      return crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']);\n    }\n  }, {\n    key: 'generateSalt',\n    value: function generateSalt() {\n      return crypto.getRandomValues(new Uint8Array(SALT_BYTES));\n    }\n  }]);\n\n  return EncryptionHelperFactory;\n}();\n\nexports.default = EncryptionHelperFactory;\n\n\nif (typeof window !== 'undefined') {\n  window.gauntface = window.gauntface || {};\n  window.gauntface.EncryptionHelperFactory = EncryptionHelperFactory;\n  window.gauntface.EncryptionHelper = EncryptionHelper;\n}\n\n},{\"./hkdf.js\":3}],3:[function(require,module,exports){\n/* eslint-env browser */\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _hmac = require('./hmac.js');\n\nvar _hmac2 = _interopRequireDefault(_hmac);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar HKDF = function () {\n  function HKDF(ikm, salt) {\n    _classCallCheck(this, HKDF);\n\n    this._ikm = ikm;\n    this._salt = salt;\n\n    this._hmac = new _hmac2.default(salt);\n  }\n\n  _createClass(HKDF, [{\n    key: 'generate',\n    value: function generate(info, byteLength) {\n      var fullInfoBuffer = new Uint8Array(info.byteLength + 1);\n      fullInfoBuffer.set(info, 0);\n      fullInfoBuffer.set(new Uint8Array(1).fill(1), info.byteLength);\n\n      return this._hmac.sign(this._ikm).then(function (prk) {\n        var nextHmac = new _hmac2.default(prk);\n        return nextHmac.sign(fullInfoBuffer);\n      }).then(function (nextPrk) {\n        return nextPrk.slice(0, byteLength);\n      });\n    }\n  }]);\n\n  return HKDF;\n}();\n\nexports.default = HKDF;\n\n\nif (typeof window !== 'undefined') {\n  window.gauntface = window.gauntface || {};\n  window.gauntface.HKDF = HKDF;\n}\n\n},{\"./hmac.js\":4}],4:[function(require,module,exports){\n/* eslint-env browser */\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar HMAC = function () {\n  function HMAC(ikm) {\n    _classCallCheck(this, HMAC);\n\n    this._ikm = ikm;\n  }\n\n  _createClass(HMAC, [{\n    key: 'sign',\n    value: function sign(input) {\n      return crypto.subtle.importKey('raw', this._ikm, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']).then(function (key) {\n        return crypto.subtle.sign('HMAC', key, input);\n      });\n    }\n  }]);\n\n  return HMAC;\n}();\n\nexports.default = HMAC;\n\n\nif (typeof window !== 'undefined') {\n  window.gauntface = window.gauntface || {};\n  window.gauntface.HMAC = HMAC;\n}\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\n/* eslint-env browser */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PushClient = function () {\n  function PushClient(stateChangeCb, subscriptionUpdate) {\n    var _this = this;\n\n    _classCallCheck(this, PushClient);\n\n    this._stateChangeCb = stateChangeCb;\n    this._subscriptionUpdate = subscriptionUpdate;\n\n    this._state = {\n      UNSUPPORTED: {\n        id: 'UNSUPPORTED',\n        interactive: false,\n        pushEnabled: false\n      },\n      INITIALISING: {\n        id: 'INITIALISING',\n        interactive: false,\n        pushEnabled: false\n      },\n      PERMISSION_DENIED: {\n        id: 'PERMISSION_DENIED',\n        interactive: false,\n        pushEnabled: false\n      },\n      PERMISSION_GRANTED: {\n        id: 'PERMISSION_GRANTED',\n        interactive: true\n      },\n      PERMISSION_PROMPT: {\n        id: 'PERMISSION_PROMPT',\n        interactive: true,\n        pushEnabled: false\n      },\n      ERROR: {\n        id: 'ERROR',\n        interactive: false,\n        pushEnabled: false\n      },\n      STARTING_SUBSCRIBE: {\n        id: 'STARTING_SUBSCRIBE',\n        interactive: false,\n        pushEnabled: true\n      },\n      SUBSCRIBED: {\n        id: 'SUBSCRIBED',\n        interactive: true,\n        pushEnabled: true\n      },\n      STARTING_UNSUBSCRIBE: {\n        id: 'STARTING_UNSUBSCRIBE',\n        interactive: false,\n        pushEnabled: false\n      },\n      UNSUBSCRIBED: {\n        id: 'UNSUBSCRIBED',\n        interactive: true,\n        pushEnabled: false\n      }\n    };\n\n    if (!('serviceWorker' in navigator)) {\n      this._stateChangeCb(this._state.UNSUPPORTED);\n      return;\n    }\n\n    if (!('PushManager' in window)) {\n      this._stateChangeCb(this._state.UNSUPPORTED);\n      return;\n    }\n\n    if (!('showNotification' in ServiceWorkerRegistration.prototype)) {\n      this._stateChangeCb(this._state.UNSUPPORTED);\n      return;\n    }\n\n    navigator.serviceWorker.ready.then(function () {\n      _this._stateChangeCb(_this._state.INITIALISING);\n      _this.setUpPushPermission();\n    });\n  }\n\n  _createClass(PushClient, [{\n    key: '_permissionStateChange',\n    value: function _permissionStateChange(permissionState) {\n      // If the notification permission is denied, it's a permanent block\n      switch (permissionState) {\n        case 'denied':\n          this._stateChangeCb(this._state.PERMISSION_DENIED);\n          break;\n        case 'granted':\n          this._stateChangeCb(this._state.PERMISSION_GRANTED);\n          break;\n        case 'default':\n          this._stateChangeCb(this._state.PERMISSION_PROMPT);\n          break;\n        default:\n          console.error('Unexpected permission state: ', permissionState);\n          break;\n      }\n    }\n  }, {\n    key: 'setUpPushPermission',\n    value: function setUpPushPermission() {\n      var _this2 = this;\n\n      this._permissionStateChange(Notification.permission);\n\n      return navigator.serviceWorker.ready.then(function (serviceWorkerRegistration) {\n        // Let's see if we have a subscription already\n        return serviceWorkerRegistration.pushManager.getSubscription();\n      }).then(function (subscription) {\n        if (!subscription) {\n          // NOOP since we have no subscription and the permission state\n          // will inform whether to enable or disable the push UI\n          return;\n        }\n\n        _this2._stateChangeCb(_this2._state.SUBSCRIBED);\n\n        // Update the current state with the\n        // subscriptionid and endpoint\n        _this2._subscriptionUpdate(subscription);\n      }).catch(function (err) {\n        console.log(err);\n        _this2._stateChangeCb(_this2._state.ERROR, err);\n      });\n    }\n  }, {\n    key: 'subscribeDevice',\n    value: function subscribeDevice() {\n      var _this3 = this;\n\n      this._stateChangeCb(this._state.STARTING_SUBSCRIBE);\n\n      // We need the service worker registration to access the push manager\n      navigator.serviceWorker.ready.then(function (serviceWorkerRegistration) {\n        return serviceWorkerRegistration.pushManager.subscribe({ userVisibleOnly: true });\n      }).then(function (subscription) {\n        _this3._stateChangeCb(_this3._state.SUBSCRIBED);\n        _this3._subscriptionUpdate(subscription);\n      }).catch(function (subscriptionErr) {\n        // Check for a permission prompt issue\n        _this3._permissionStateChange(Notification.permission);\n\n        if (Notification.permission !== 'denied' && Notification.permission !== 'default') {\n          // If the permission wasnt denied or prompt, that means the\n          // permission was accepted, so this must be an error\n          _this3._stateChangeCb(_this3._state.ERROR, subscriptionErr);\n        }\n      });\n    }\n  }, {\n    key: 'unsubscribeDevice',\n    value: function unsubscribeDevice() {\n      var _this4 = this;\n\n      // Disable the switch so it can't be changed while\n      // we process permissions\n      // window.PushDemo.ui.setPushSwitchDisabled(true);\n\n      this._stateChangeCb(this._state.STARTING_UNSUBSCRIBE);\n\n      navigator.serviceWorker.ready.then(function (serviceWorkerRegistration) {\n        return serviceWorkerRegistration.pushManager.getSubscription();\n      }).then(function (pushSubscription) {\n        // Check we have everything we need to unsubscribe\n        if (!pushSubscription) {\n          _this4._stateChangeCb(_this4._state.UNSUBSCRIBED);\n          _this4._subscriptionUpdate(null);\n          return;\n        }\n\n        // TODO: Remove the device details from the server\n        // i.e. the pushSubscription.subscriptionId and\n        // pushSubscription.endpoint\n        return pushSubscription.unsubscribe().then(function (successful) {\n          if (!successful) {\n            // The unsubscribe was unsuccessful, but we can\n            // remove the subscriptionId from our server\n            // and notifications will stop\n            // This just may be in a bad state when the user returns\n            console.error('We were unable to unregister from push');\n          }\n        });\n      }).then(function () {\n        _this4._stateChangeCb(_this4._state.UNSUBSCRIBED);\n        _this4._subscriptionUpdate(null);\n      }).catch(function (err) {\n        console.error('Error thrown while revoking push notifications. ' + 'Most likely because push was never registered', err);\n      });\n    }\n  }]);\n\n  return PushClient;\n}();\n\nexports.default = PushClient;\n\n},{}]},{},[1]);\n"],"file":"scripts/app-controller.js","sourceRoot":"/source/"}